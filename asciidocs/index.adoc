= Course Notes for "Apps with Web Components, redux and lit-html"
firstname lastname
1.0.0, 2020-06-25: Trainer: Adam Bien
ifndef::imagesdir[:imagesdir: images]
//:toc-placement!:  // prevents the generation of the doc at this position, so it can be printed afterwards
:sourcedir: ../src/main/java
:icons: font
:sectnums:    // Nummerierung der Überschriften / section numbering
:toc: left

//Need this blank line after ifdef, don't know why...
ifdef::backend-html5[]

// https://fontawesome.com/v4.7.0/icons/
icon:file-text-o[link=https://raw.githubusercontent.com/htl-leonding-college/asciidoctor-docker-template/master/asciidocs/{docname}.adoc] ‏ ‏ ‎
icon:github-square[link=https://github.com/htl-leonding-college/asciidoctor-docker-template] ‏ ‏ ‎
icon:home[link=https://htl-leonding.github.io/]
endif::backend-html5[]

// print the toc here (not at the default position)
//toc::[]


== GitHub-Repo

https://github.com/htl-leonding/redux-web-components-adam-bien-course

== Preparations

=== Install browser-sync

----
npm install -g browser-sync
----

=== Create your first app

----
|-- events
    `-- src
        |-- app.js
        |-- index.html
        `-- style.css // <.>
----

<.> style.css is empty at the moment

.index.html
[source,html]
----
<!DOCTYPE html>
<html lang="en">
<head>
    <title>[my template]</title>
    <link rel="stylesheet" href="style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <code>hello</code>
    <script src="app.js"></script>
</body>
</html>
----


.app.js
[source,javascript]
----
console.log("Hello Web Standards");
----

Start browser-sync

```
browser-sync start -s src -f src -b "google chrome" --no-notify
```

.https://www.browsersync.io/docs/command-line[browsersync options]
|===
|Option |Description
|-s
|Start a Local server from the `src`-directory
|-f
|File paths to watch - here: `src`
|-b
|Choose which browser should be auto-opened
|===

.Result in Browser
image:primer-browser.png[]

////
=== Install Snowpack

https://www.snowpack.dev/

For installing redux; Snowpack is a intelligent builder which
converts the proprietary module system from redux and lit-html to es6-modules.

//.Click, for the install-details
//[%collapsible]
//====

First we make a new "project"-folder beside `events`:

[source,shell]
----
mkdir dependencies
cd dependencies
npm init -y
npm i redux
----

.package.json
[source,yaml]
----
{
  "name": "dependencies",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "redux": "^4.0.5"
  }
}
----


// snowpack is not needed because redux now provides a working redux.mjs-file

----
npm install --save-dev snowpack
----

[source,yaml]
----
{
  "name": "dependencies",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "redux": "^4.0.5"
  },
  "devDependencies": {
    "snowpack": "^2.5.4"
  }
}
----

==== Add a simple js-File

.src/app.js
[source,javascript]
----
import 'redux/dist/redux.js'
----

image:add-app-js-for-snowpack.png[]

.Convert redux to es6-module
----
npx snowpack
----

image:install-snowpack.png[]


.Redux converted to ES6-module
image:redux-converted-to-es6-module.png[]


==== Copy the Redux-Lib

----
cd ../events
mkdir src/lib
cp ../dependencies/web_modules/redux/dist/redux.js ./src/lib
----

----
|-- events
|   `-- src
|       |-- app.js
|       |-- index.html
|       |-- lib
|       |   `-- redux.js
|       `-- style.css
----

// comment: it doesn't work with snowpack

// ====

////


=== Use the redux.mjs - file

==== Install redux in a separate "project"

First we make a new "project"-folder beside `events`:

[source,shell]
----
mkdir dependencies
cd dependencies
npm init -y
npm i redux
----

.package.json
[source,yaml]
----
{
  "name": "dependencies",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "redux": "^4.0.5"
  }
}
----


==== Copy the redux.mjs - File


----
cd ../events
mkdir src/lib
cp ../dependencies/node_modules/redux/es/redux.mjs ../events/src/lib
----

----
|-- events
|   `-- src
|       |-- app.js
|       |-- index.html
|       |-- lib
|       |   `-- redux.mjs
|       `-- style.css
----

..mjs-files - module javascript
****

.MJS file

* mjs is an extension for EcmaScript modules
* An MJS file is a source code file containing an ES Module (ECMAScript Module) for use with a Node.js application.
* MJS files are written in JavaScript, and may also use the .JS extension outside of the Node.js context.
* ES Modules allow web and application developers to organize code into smaller reusable components.

ECMAScript 6 (ES6) introduced the specification for ES Modules, providing a standard for implementing modules in JavaScript. As of 2018, all major web browsers support ES Modules.

However, the popularity of modularized JavaScript pre-dates ES6. Node.js, a JavaScript runtime environment, used CommonJS as the specification for modules. *Because so many existing applications were built with CommonJS, when Node.js added support for native ES modules, it controversially introduced the MJS file extension to differentiate the two and prevent applications from breaking*.

https://stackoverflow.com/a/57557669/9818338
****




=== Activate Module System

.index.html
[source,html]
----
<!DOCTYPE html>
<html lang="en">
<head>
    <title>[WebStandards template]</title>
    <link rel="stylesheet" href="style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <code>hello</code>
    <script src="app.js" type="module"></script> <.>
</body>
</html>
----

<.> `type="module"` activates the module system. In Node.js the native module system is *CommonJS*.
To activate the newer *ES6 module system* you have to use *module*.




=== Redux

Redux is a central Singleton, where we can store json- or javascript-objects.
These objects can only modified by functions, called reducers.
We can subscribe to notifications of this store.


== The Program

[source,javascript]
----
import { createStore } from "./lib/redux.js";

const multiply = ( state = 21, action) => {
    console.log(state, action);
    return state * action.payload;
}

const store = createStore(multiply);

const initial = store.getState();
console.log('initial', initial);
----

.Problem: the first 'action' is a init-action, so the action-type has to be determined
image:first-program.png[]

[source,javascript]
----
import { createStore } from "./lib/redux.mjs";

const multiply = ( state = 21, action) => {
    console.log(state, action);
    if (action.type === 'M') {
        return state * action.payload;
    }
    return state;
}

const store = createStore(multiply);

const initial = store.getState();
console.log('initial', initial);
----

.only the state is displayed
image:first-program-2.png[]

=== Create a Subscription

[source,javascript]
----
import { createStore } from "./lib/redux.mjs";

const multiply = ( state = 21, action) => {
    console.log(state, action);
    if (action.type === 'M') {
        return state * action.payload;
    }
    return state;
}

const store = createStore(multiply);

// subscribe to changes
store.subscribe(_ => console.log('state changed', store.getState())); // <.>

const initial = store.getState();
console.log('initial', initial);

// changes the value
store.dispatch({ // <.>
    type: 'M',
    payload: 2
})

console.log(store.getState());
----

<.> subscribe to changes
<.> changes the value

image:first-program-3-subscription.png[]

=== Redux DevTools

https://github.com/zalmoxisus/redux-devtools-extension

to install use this link for chrome store +
https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd


Now add a second parameter:

[source,javascript]
----
const store = createStore(multiply, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
----

.When the icon in the toolbar gets green, the extension is activated (-> reload)
image:redux-dev-tools-for-chrome.png[]


.Add a value
[source,javascript]
----
store.dispatch({
    type: 'M',
    payload: 3
})
----

.app.js
[source,javascript]
----
import { createStore } from "./lib/redux.mjs";

const multiply = ( state = 21, action) => {
    console.log(state, action);
    if (action.type === 'M') {
        return state * action.payload;
    }
    return state;
}

const store = createStore(multiply, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());

// subscribe to changes
store.subscribe(_ => console.log('state changed', store.getState()));

const initial = store.getState();
console.log('initial', initial);

// change the value
store.dispatch({
    type: 'M',
    payload: 2
})
store.dispatch({
    type: 'M',
    payload: 3
})


console.log(store.getState());
----


image:redux-dev-tools-2.png[]
image:redux-dev-tools-3.png[]


=== Create a First Component

.NewEvent,js
[source,javascript]
----
class NewEvent extends HTMLElement {
    connectedCallback() {
        this.innerHTML = "simple string"
    }
}

customElements.define('a-newevent', NewEvent);
----

.app.js
[source,javascript]
----
import './NewEvent.js'
----

.index.html
[source,html]
----
<!DOCTYPE html>
<html lang="en">
<head>
    <title>[WebStandards template]</title>
    <link rel="stylesheet" href="style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <a-newevent />  <.>
    <script src="app.js" type="module"></script>
</body>
</html>
----

<.> Usage of the new tag


=== Structuring of the App

* In the highest level we use a functional structure.
* In the creation-folder are created
** boundary-
** entity- and
** control-packages

----
events
|-- app.js
|-- creation
|   |-- boundary
|   |   `-- NewEvent.js
|   |-- control
|   `-- entity
|-- index.html
|-- lib
|   `-- redux.mjs
`-- style.css
----

==== Install lit-html

Open a terminal

----
mkdir dependencies
cd dependencies
npm init -y
npm i lit-html
npm i --save-deps snowpack
mkdir src
echo "import 'lit-html/lit-html.js'" > src/app.js
snowpack build
 cp ./web_modules/lit-html/lit-html.js ../events/src/lib/
----

According to https://twitter.com/AdamBien/status/1283265671955132417[AdamBien] it is sufficient to copy
the entire folder.

=== Input Elements and Change Listener

==== Usage of `html`

.NewEvent.js
[source,javascript]
----
import { render, html } from "../../lib/lit-html.js"; // <.>

class NewEvent extends HTMLElement {
    connectedCallback() {
        this.innerHTML = html`  // <.>
          <input placeholder="name" />
          <button>create</button>
        `;
    }
}

customElements.define('a-newevent', NewEvent);
----

<.> imports the functions `render` and `html` from lit-html
<.> uses the function `html`

.The template is an object - we will have to render it
image:less006-lit-html-object.png[]


==== Rendering the template object

[source,javascript]
----
import { render, html } from "../../lib/lit-html.js";

class NewEvent extends HTMLElement {
    connectedCallback() {
        const template = html`  // <.>
          <input placeholder="name" />
          <button>create</button>
        `;
        render(template, this);  // <.>
    }
}

customElements.define('a-newevent', NewEvent);
----

<.> assign the html-code as object to a variable ...
<.> ... and render the template object

.The rendered template object
image:less006-lit-html-object-render.png[]


==== Now we add additional functionality


.NewEvent.js
[source,javascript]
----
import {render, html} from "../../lib/lit-html.js";

class NewEvent extends HTMLElement {
    connectedCallback() {
        const template = html`
          <input placeholder="name" />
          <button @click="${_ => this.newEvent()}">create</button>
        `;
        render(template, this);
    }

    newEvent() {
        console.log('-------- button clicked');
    }
}

customElements.define('a-newevent', NewEvent);
----

image:less006-lit-html-button-click.png[]

==== Add @change to input-element

[source,javascript]
----
import {render, html} from "../../lib/lit-html.js";

class NewEvent extends HTMLElement {
    connectedCallback() {
        const template = html`
          <input @change=${e=>this.onUserInput(e)} placeholder="name" /> // <.>
          <button @click="${_ => this.newEvent()}">create</button>
        `;
        render(template, this);
    }

    newEvent() {
        console.log('-------- button clicked');
    }

    onUserInput(e) {  // <.>
        console.log(e);
    }
}

customElements.define('a-newevent', NewEvent);
----

<.> add `@change=${e=>this.onUserInput(e)}`
<.> create a function to log the event

image:less007-event-in-console.png[]

The event has a target, which is basically the input - field. The target owns (beside others) two properties:
name (is currently empty) and value (the text in the input field)

So we are providing a name-property to the input field.

We are also extracting the name and the value in the function.

==== Extract Parts from the Event

[source,javascript]
----
import {render, html} from "../../lib/lit-html.js";

class NewEvent extends HTMLElement {
    connectedCallback() {
        const template = html`
          <input name="eventname"  <.>
                 @change=${e=>this.onUserInput(e)}
                 placeholder="name"
          />
          <button @click="${_ => this.newEvent()}">create</button>
        `;
        render(template, this);
    }

    newEvent() {
        console.log('-------- button clicked');
    }

    onUserInput({target: { name, value }}) {   <.>
        console.log(name, value); <.>
    }
}

customElements.define('a-newevent', NewEvent);
----

<.> provide a name attribute
<.> extract parts of the event-object
<.> log to the console

==== Create a Custom Event-Object

[source,javascript]
----
import {render, html} from "../../lib/lit-html.js";

class NewEvent extends HTMLElement {

    constructor() {
        super();
        this.event = {};  <.>
    }


    connectedCallback() {
        const template = html`
          <input name="eventname" @change=${e=>this.onUserInput(e)} placeholder="eventname" />
          <input name="description" @change=${e=>this.onUserInput(e)} placeholder="description" />  <.>
          <button @click="${_ => this.newEvent()}">create</button>
        `;
        render(template, this);
    }

    newEvent() {
        console.log('-------- saving', this.event);  <.>
    }

    onUserInput({target: { name, value }}) {
        console.log(name, value);
        this.event[name] = value;  <.>
    }
}

customElements.define('a-newevent', NewEvent);
----

<.> add a constructor and create an custom event-object
<.> add a second input field (description)
<.> imagine, the event object is saved in this function
<.> add each data item to the event-object

image:less007-custom-event-object.png[]


=== Creation of an Overview Web Component

==== Create a new Overview Component

image:less009-project-structure.png[]

.EventsOverview.js
[source,javascript]
----
class EventsOverview extends HTMLElement {

    connectedCallback() {
        this.innerHTML = `
        <h2>hello,overview</h2>
        `;
    }
}

customElements.define('a-events-overview', EventsOverview);
----

.app.js
[source,javascript]
----
import './creation/boundary/NewEvent.js';
import './overview/boundary/EventsOverview.js'; // <.>
----

<.> add the js-File

.index.html
[source,html]
----
<!DOCTYPE html>
<html lang="en">
<head>
    <title>[WebStandards template]</title>
    <link rel="stylesheet" href="style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
    <a-newevent></a-newevent>
    <a-events-overview></a-events-overview> <.>
    <script src="app.js" type="module"></script>
</body>
</html>
----

<.> use the custom element on your page.

NOTE: Don't use `<a-events-overview />` because some browsers doesn't recognize it.


image:less009-result-in-browser.png[]


NOTE: you can add the custom tags in index.html to customElements in IntelliJ (right-click)


=== Extract the Common Logic to a "Base" Component

==== Same Code for Rendering Custom Elements

.use lit-html in the custom element
[source,javascript]
----
import { html, render } from "../../lib/lit-html.js";

class EventsOverview extends HTMLElement {

    connectedCallback() {
        const template = html`  <.>
        <h2>hello,overview</h2>
        `;
        render(template, this); <.>
    }
}

customElements.define('a-events-overview', EventsOverview);
----

<.> add `html`
<.> add `render(...)`

Now it is the same like before - we use `html` and `render(...)`.
We can create an generic custom element -> AirElement.

==== Introduce AirElement

Maybe BaseElement would be a better name.

.AirElement.js
[source,javascript]
----
import { render } from './lib/lit-html.js'

export default class AirElement extends HTMLElement {  // <4>

    connectedCallback() {
        const template = this.view(); // <2>
        render(template, this);  // <3>
    }

    view() { } // <1>

}
----

<.> create an abstract method
<.> the abstract method returns the template
<.> ... which we will render
<.> don't forget to export the class

.NewEvent.js
[source,javascript]
----
import { render, html } from "../../lib/lit-html.js";
import AirElement from "../../AirElement.js";

class NewEvent extends AirElement { // <.>

    constructor() {
        super();
        this.event = {};
    }


    view() {   // <.>
        return html`
          <input name="eventname" @change=${e=>this.onUserInput(e)} placeholder="eventname" />
          <input name="description" @change=${e=>this.onUserInput(e)} placeholder="description" />
          <button @click="${_ => this.newEvent()}">create</button>
        `;
     // <.>
    }

    newEvent() {
        console.log('-------- saving', this.event);
    }

    onUserInput({target: { name, value }}) {
        console.log(name, value);
        this.event[name] = value;
    }
}

customElements.define('a-newevent', NewEvent);
----

<.> Now, we derive from AirElement
<.> We implement the abstract method
<.> we don't have to render the template here, because this will be done in AirElement

.EventsOverview.js
[source,javascript]
----
import { html, render } from "../../lib/lit-html.js";
import AirElement from "../../AirElement.js";

class EventsOverview extends AirElement {

    view() {
        return html`
        <h2>hello,overview</h2>
        `;
    }
}

customElements.define('a-events-overview', EventsOverview);
----

Now it will work like before.

=== The Reduce Integration

==== Create EventControl

The new class EventControl centralizes the click-handler.

.EventControl.js
[source,javascript]
----
const createEvent = event => {
    console.log('in control ', event);
}

export { createEvent };
----

.NewEvent.js
[source,javascript]
----
import { render, html } from "../../lib/lit-html.js";
import AirElement from "../../AirElement.js";   // <.>
import {createEvent} from "../control/EventControl.js";

class NewEvent extends AirElement {

    constructor() {
        super();
        this.event = {};
    }

    view() {
        return html`
          <input name="eventname" @change=${e=>this.onUserInput(e)} placeholder="eventname" />
          <input name="description" @change=${e=>this.onUserInput(e)} placeholder="description" />
          <button @click="${_ => this.newEvent()}">create</button>
        `;
    }

    onUserInput({target: { name, value }}) {
        console.log(name, value);
        this.event[name] = value;
    }

    newEvent() {
        createEvent(this.event);  // <.>
    }

}

customElements.define('a-newevent', NewEvent);
----

<.> import createEvent(...)
<.> invoke createEvent(...)

image:less011-result-in-browser.png[]

The createEvent-function is a perfect place to dispatch redux-actions.

==== Introduce Redux

Because EventsOverview and NewEvent share the super class AirElement, we can use AirElement.
In Redux we need https://redux.js.org/basics/actions[actions] and https://redux.js.org/basics/reducers[reducers].

NOTE: There is a good article: https://www.robinwieruch.de/javascript-reducer[What is a Reducer in JavaScript/React/Redux?]

On every modification of the state of the redux store, we will rerender all components.

.AirElement.js
[source,javascript]
----
import { render } from './lib/lit-html.js'
import {createStore} from "./lib/redux.mjs"; // <.>

const events = (state = {}, action) => {  // <.>
    console.log(state, action);
    return state;
}
const store = createStore(events);  // <.>

export default class AirElement extends HTMLElement {

    connectedCallback() {
        store.subscribe(_ => this.triggerViewUpdate()); // <.>
        this.triggerViewUpdate(); // <.>
    }

    triggerViewUpdate() {  // <.>
        const template = this.view();
        render(template, this);
    }

    view() { }

}

export {store}; // <.>
----

<.> import redux
<.> create a reducer
<.> create a store
<.> on every change invoke `triggerViewUpdate()`
<.> for initialization
<.> renders the view. lit-html is smart, detects all changes and rerender them
<.> add another export

.EventControl.js
[source,javascript]
----
import {store} from "../../AirElement.js" // <.>

const createEvent = payload => {
    store.dispatch({  // <.>
        type: 'NEW_EVENT_CREATED',
        payload
    });
}

export { createEvent };
----

<.> import the store
<.> dispatch the payload

.NewEvent.js
[source,javascript]
----
import { render, html } from "../../lib/lit-html.js";
import AirElement from "../../AirElement.js";
import {createEvent} from "../control/EventControl.js";

class NewEvent extends AirElement {

    constructor() {
        super();
        this.event = {};
    }

    view() {
        console.log('UPDATED');
        return html`
          <input name="eventname"
                 @change=${e=>this.onUserInput(e)}
                 placeholder="eventname" />
          <input name="description"
                 @change=${e=>this.onUserInput(e)}
                 placeholder="description" />
          <button @click="${_ => this.newEvent()}">create</button>
        `;
    }

    onUserInput({target: { name, value }}) {
        console.log(name, value);
        this.event[name] = value;
    }

    newEvent() {
        createEvent(this.event)
    }

}

customElements.define('a-newevent', NewEvent);
----

.EventsOverview.js
[source,javascript]
----
import { html, render } from "../../lib/lit-html.js";
import AirElement from "../../AirElement.js";


class EventsOverview extends AirElement {

    view() {
        console.log('UPDATING +1');
        return html`
        <h2>hello,overview</h2>
        `;
    }
}

customElements.define('a-events-overview', EventsOverview);
----


image:less011-redux-result-in-browser.png[]

=== Sending Events to Redux Store

==== Reactivate Redux tools

.AirElement.js
[source,javascript]
----
import { render } from './lib/lit-html.js'
import {createStore} from "./lib/redux.mjs";

// reducer
const events = (state = {}, action) => {
    console.log(state, action);
    return state;
}
const store = createStore(events, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()); // <.>

export default class AirElement extends HTMLElement {

    connectedCallback() {
        store.subscribe(_ => this.triggerViewUpdate());
        this.triggerViewUpdate();
    }

    triggerViewUpdate() {
        const template = this.view();
        render(template, this);
    }

    view() { }

}

export {store};
----

<.> add the initialization sequence

image:less012-redux-devtools.png[]

The current state is just an empty object

.AirElement.js
[source,javascript]
----
const events = (state = {events:[]}, action) => { // <.>
    console.log(state, action);
    return state;
}
----

<.> add an empty array of events to the state

You can see this in the redux devtools immediately.

image:less012-redux-devtools-events-array.png[]



.AirElement.js
[source,javascript]
----
...
const events = (state = {events:[]}, action) => {
    const {type,payload} = action;
    switch (type) {
        case 'NEW_EVENT_CREATED':
            return {
                events: state.events.concat(payload)
            }
    }
    console.log(state, action);
    return state;
}
const store = createStore(events, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
...
----

image:less012-redux-devtools-results.png[]


=== Sharing State between Components

The easist way is to provide AirElement with the state.

.AirElement.js
[source,javascript]
----
...
export default class AirElement extends HTMLElement {

    constructor() {  // <.>
        super();
        this.state = {};
    }

    connectedCallback() {
        store.subscribe(_ => this.triggerViewUpdate());
        this.triggerViewUpdate();
    }

    triggerViewUpdate() {
        this.state = store.getState();  // <.>
        const template = this.view();
        render(template, this);
    }

    view() { }

}
...
----

<.> create a state - variable ...
<.> ... and assign the actual store-content to her when rendering

.EventsOverview.js
[source,javascript]
----
import { html, render } from "../../lib/lit-html.js";
import AirElement from "../../AirElement.js";


class EventsOverview extends AirElement {

    view() {
        console.log('UPDATING +1',this.state);  // <.>
        return html`
        <h2>hello,overview</h2>
        `;
    }
}

customElements.define('a-events-overview', EventsOverview);
----

image:less013-result-in-browser.png[]


=== Rendering a List

.EventsOverview.js
[source,javascript]
----
import {html, render} from "../../lib/lit-html.js";
import AirElement from "../../AirElement.js";


class EventsOverview extends AirElement {

    view() {
        const eventList = this.state.events;
        console.log('UPDATING +1', this.state);
        return html`
        <ol>
         ${eventList.map(({ name, description}) => html`
             <li>${eventname} => ${description}</li>
         `)}
        </ol>
        `;
    }
}

customElements.define('a-events-overview', EventsOverview);
----

image:less014-result-in-browser.png[]

It doesn't work!

==== Fixing the reference-error (now copying)

// This solution works, but it's more structured to copy the event in the reducer
////
[source,javascript]
----
import {store} from "../../AirElement.js"

const createEvent = event => {
    const payload = Object.assign({}, event); // <.>
    store.dispatch({
        type: 'NEW_EVENT_CREATED',
        payload
    });
}

export { createEvent };
----

<.> Copies the event, instead of referencing

image:less015-result-in-browser.png[]
////

.AirElement.js
[source,javascript]
----
...
const deepCopy = input => JSON.parse(JSON.stringify(input));  // <.>

// reducer
const events = (state = {events:[]}, action) => {
    const {type,payload} = action;
    switch (type) {
        case 'NEW_EVENT_CREATED':
            return deepCopy({    // <.>
                events: state.events.concat(payload)
            });
    }
    console.log(state, action);
    return state;
}
...
----

<.> create a new function for deep copying
<.> instead of a reference, provide a copy

image:less016-result-in-browser.png[]


=== Refactoring Redux

First, we will factor out the redux logic from AirElement in a dedicated file.

.AirElement.js
[source,javascript]
----
import { render } from './lib/lit-html.js'
import store from "./store.js";

export default class AirElement extends HTMLElement {

    constructor() {
        super();
        this.state = {};
    }

    connectedCallback() {
        store.subscribe(_ => this.triggerViewUpdate());
        this.triggerViewUpdate();
    }

    triggerViewUpdate() {
        this.state = store.getState();
        const template = this.view();
        render(template, this);
    }

    view() { }

}
export {store};
----

.store.js
[source,javascript]
----
import {createStore} from "./lib/redux.mjs";

const deepCopy = input => JSON.parse(JSON.stringify(input));

// reducer
const events = (state = {events:[]}, action) => {
    const {type,payload} = action;
    switch (type) {
        case 'NEW_EVENT_CREATED':
            return deepCopy({
                events: state.events.concat(payload)
            });
    }
    console.log(state, action);
    return state;
}
const store = createStore(events, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
export default store;
----

image:less017-result-in-browser.png[]

.EventControl.js
[source,javascript]
----
import store from "../../store.js"; // <.>

const createEvent = payload => {
    store.dispatch({
        type: 'NEW_EVENT_CREATED',
        payload
    });
}

export { createEvent };
----

=== Extract Businesslogic

.src/store.js
[source,javascript]
----
import {createStore} from "./lib/redux.mjs";
import events from "./creation/entity/EventsReducer.js";

const store = createStore(events, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
export default store;
----

.src/creation/entity/EventsReducer.js
[source,javascript]
----
const deepCopy = input => JSON.parse(JSON.stringify(input));

// reducer
const events = (state = {events:[]}, action) => {
    const {type,payload} = action;
    switch (type) {
        case 'NEW_EVENT_CREATED':
            return deepCopy({
                events: state.events.concat(payload)
            });
    }
    console.log(state, action);
    return state;
}

export default events;
----

=== Introduce a Constant for a String (Action Type)

.EventsReducer.js
[source,javascript]
----
const deepCopy = input => JSON.parse(JSON.stringify(input));

const NEW_EVENT_CREATED = 'NEW_EVENT_CREATED';  // <.>

// reducer
const events = (state = {events:[]}, action) => {
    const {type,payload} = action;
    switch (type) {
        case NEW_EVENT_CREATED:   // <.>
            return deepCopy({
                events: state.events.concat(payload)
            });
    }
    console.log(state, action);
    return state;
}

export default events;
export { NEW_EVENT_CREATED };
----

.EventControl.js
[source,javascript]
----
import store from "../../store.js";
import {NEW_EVENT_CREATED} from "../entity/EventsReducer.js";


const createEvent = payload => {
    store.dispatch({
        type: NEW_EVENT_CREATED,
        payload
    });
}

export { createEvent };
----








[source,javascript]
----

----



[source,javascript]
----

----

[source,javascript]
----

----



[source,javascript]
----

----

[source,javascript]
----

----



[source,javascript]
----

----

[source,javascript]
----

----


















